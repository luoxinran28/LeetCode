# Design Netflix

最基本的SNAKE原则是应用场景Scenario，限制性条件 Necessary，设计应用Application，数据存储结构Kilobit，扩展Evolve。

## Scenario:

枚举可能的场景，分类电影，挑选电影，播放电影，推荐电影等等。这里最重要的就是能播放电影，不然网站就没有什么用处。

## Necessary：

### QPS:

假设Netflix有10,000,000日活用户DAU，平均在线时长是1.5小时。

平均并发用户Average Concurrent Users = 日活用户 / 每日描述 \* 平均在线时长 = 10,000,000 / \(24 \* 60 \* 60\) \* \(90 \* 60\) = 0.625M 

Peak Concurrent Users = 0.625M \* 3 = 1.875M

Peak Concurrent Users after 1 year = 1.875M \* 2 = 3.75M

假设我们平时看视频的流量是30mbps

The top traffic after 1 year = 3.75M \* 10mpbs = 37.5Pb/s

### Storage:

假设单个用户使用内存约为20KB，一年后需要的总内存 = 10,000,000 \* 2 \* 20k = 400GB。

电影数量为20,000，平均每部电影100GB，所以总硬盘 = 100GB \* 20,000 = 2PB。

## Application:

![](../.gitbook/assets/image%20%2812%29.png)

## Kilobit:

存储用户信息，由于需要经常修改和查找，并且要保证一致性，我们可以选用MySQL；频道信息添加操作比较频繁，可以使用MongoDB；而电影只需要用保存文件就可以，不需要使用数据库。

## Evolve:

对基本设计进行优化，我们有三个方向可以考虑：更好，例如如何满足更多用户量，如何更鲁棒；更广，例如设计更多应用场景，增加更多功能；更深，考虑更多细节。



## 设计Feature：设计一个推荐模块

首先是场景，我可以定义一个Recommender的接口，类里定义一个方法找到最相似用户，输入是一个用户ID，返回这个用户的最相似用户ID。

再考虑限制性条件（Necessary），假设这个推荐模块每10分钟重新为每个用户推荐一次，结合之前计算出的三个月后的高峰用户数，可以得到三个月后的高峰QPS（Query Per Second）。

![](../.gitbook/assets/image%20%2810%29.png)

首先看看最直观的算法，我们将两个用户喜欢的电影一一比较，就可以得到两个用户之间的Similarity。但是这种算法的复杂度非常高，进行了3\*2+3\*4=18次比较，这种算法无法满足需求，所以要对算法进行进化（Evolve）。

  


![](../.gitbook/assets/image%20%2811%29.png)

我们可以通过建立倒排索引来减小计算复杂度，从而提升性能。即从每个用户喜欢哪些电影转变为每部电影被哪些用户喜欢。我们知道用户u1喜欢电影m1、m3和m7，我们就可以通过查询倒排索引，找到也喜欢m1、m3和m7的用户，这些用户都和u1相似。这样我们只进行3次计算就得到了其它用户和u1的similarity，大大降低了算法的时间复杂度。

![](../.gitbook/assets/image%20%2814%29.png)

